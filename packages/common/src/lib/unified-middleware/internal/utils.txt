import { UnifiedHttpContext } from "../../type/unified/unified-context";
import { UnifiedHttpContextWithState, UnifiedMiddleware, UnifiedMiddlewareContext, UnifiedMiddlewareEntry, UnifiedMiddlewareOptions, UnifiedRouteHandler } from "../../type/unified/unified-middleware";
// foundations/middleware/utils.ts - Pure functions for testing
export const sortMiddlewaresByOrder = (middlewares: UnifiedMiddlewareEntry[]): UnifiedMiddlewareEntry[] => {
  return middlewares.sort((a, b) => (a.options.order ?? 0) - (b.options.order ?? 0));
};

export const shouldSkipMiddleware = (
  options: UnifiedMiddlewareOptions, 
  context: UnifiedHttpContext
): boolean => {
  return options.condition ? !options.condition(context) : false;
};

export const createTimeoutPromise = (timeoutMs: number, middlewareName?: string): Promise<never> => {
  return new Promise<never>((_, reject) => {
    setTimeout(() => {
      const name = middlewareName ?? 'Unknown middleware';
      reject(new Error(`${name} timeout after ${timeoutMs}ms`));
    }, timeoutMs);
  });
};

export const executeMiddlewareWithTimeout = async (
  middleware: UnifiedMiddleware,
  context: UnifiedHttpContext,
  next: () => Promise<void>,
  timeoutMs?: number
): Promise<void> => {
  if (timeoutMs) {
    const timeoutPromise = createTimeoutPromise(timeoutMs, middleware.name);
    await Promise.race([middleware(context, next), timeoutPromise]);
  } else {
    await middleware(context, next);
  }
};

export const createMiddlewareDispatcher = (
  sortedMiddlewares: UnifiedMiddlewareEntry[],
  handler: UnifiedRouteHandler,
  middlewareContext: UnifiedMiddlewareContext
) => {
  let index = 0;
  
  const dispatch = async (context: UnifiedHttpContext): Promise<void> => {
    if (middlewareContext.skipRemainingMiddlewares) {
      return;
    }

    if (index >= sortedMiddlewares.length) {
      await handler(context);
      return;
    }
    
    const { middleware, options } = sortedMiddlewares[index++];
    
    // Check condition if specified
    if (shouldSkipMiddleware(options, context)) {
      await dispatch(context);
      return;
    }

    // Execute middleware with optional timeout
    await executeMiddlewareWithTimeout(
      middleware, 
      context, 
      () => dispatch(context), 
      options.timeout
    );
  };

  return dispatch;
};

export const attachMiddlewareContext = (
  context: UnifiedHttpContext, 
  middlewareContext: UnifiedMiddlewareContext
): UnifiedHttpContext & { middleware: UnifiedMiddlewareContext } => {
  return Object.assign(context, { middleware: middlewareContext });
};

// Utility functions for response state tracking
export const initializeMiddlewareState = (context: UnifiedHttpContextWithState): void => {
  context.__middlewareState ??= {
    statusCode: undefined,
    sent: false,
    headers: {}
  };
};

export const trackResponseStatus = (context: UnifiedHttpContextWithState, statusCode: number): void => {
  initializeMiddlewareState(context);
  if (context.__middlewareState) {
    context.__middlewareState.statusCode = statusCode;
  }
};

export const markResponseSent = (context: UnifiedHttpContextWithState): void => {
  initializeMiddlewareState(context);
  if (context.__middlewareState) {
    context.__middlewareState.sent = true;
  }
};

export const getResponseStatus = (context: UnifiedHttpContextWithState): number | undefined => {
  return context.__middlewareState?.statusCode;
};

export const isResponseSent = (context: UnifiedHttpContextWithState): boolean => {
  return context.__middlewareState?.sent || false;
};
