// foundations/middleware/logging.ts
import { 
  UnifiedMiddleware, 
  UnifiedHttpContextWithState
} from '../../type/unified/unified-middleware';
import { 
  initializeMiddlewareState, 
  trackResponseStatus, 
  getResponseStatus 
} from '../internal/utils';

export interface UnifiedLoggingOptions {
  includeBody?: boolean;
  includeHeaders?: boolean;
  includeUserAgent?: boolean;
  skipPaths?: string[];
  sensitiveHeaders?: string[];
  maxBodyLength?: number;
}

export const createLoggingMiddleware = (options: UnifiedLoggingOptions = {}): UnifiedMiddleware => {
  const {
    includeBody = false,
    includeHeaders = false,
    includeUserAgent = true,
    skipPaths = ['/health', '/metrics'],
    sensitiveHeaders = ['authorization', 'cookie', 'x-api-key'],
    maxBodyLength = 1000
  } = options;

  return async (context, next) => {
    const contextWithState = context as UnifiedHttpContextWithState;
    initializeMiddlewareState(contextWithState);
    
    const startTime = Date.now();
    const { method, url, headers, ip } = context.request;
    
    // Skip logging for health checks and metrics
    if (skipPaths.some(path => url.includes(path))) {
      await next();
      return;
    }

    // Prepare request info
    const requestInfo: Record<string, unknown> = {
      method,
      url,
      ip,
      timestamp: new Date().toISOString()
    };

    if (includeUserAgent) {
      requestInfo.userAgent = headers['user-agent'];
    }

    if (includeHeaders) {
      requestInfo.headers = Object.fromEntries(
        Object.entries(headers).filter(
          ([key]) => !sensitiveHeaders.includes(key.toLowerCase())
        )
      );
    }

    if (includeBody && context.request.body) {
      const bodyString = JSON.stringify(context.request.body);
      requestInfo.body = bodyString.length > maxBodyLength 
        ? bodyString.substring(0, maxBodyLength) + '...[truncated]'
        : bodyString;
    }

    console.log(`→ ${method} ${url}`, requestInfo);

    let error: Error | null = null;
    try {
      // Intercept response.status to track status code
      const originalStatus = context.response.status;
      context.response.status = function(code: number) {
        trackResponseStatus(contextWithState, code);
        return originalStatus.call(this, code);
      };

      await next();
    } catch (err) {
      error = err instanceof Error ? err : new Error(String(err));
      throw err;
    } finally {
      const duration = Date.now() - startTime;
      const statusCode = getResponseStatus(contextWithState) || (error ? 500 : 200);
      
      const responseInfo: Record<string, unknown> = {
        statusCode,
        duration: `${duration}ms`,
        timestamp: new Date().toISOString()
      };

      if (error) {
        responseInfo.error = error.message;
      }

      console.log(`← ${method} ${url} ${statusCode} (${duration}ms)`, responseInfo);
    }
  };
};